import React, { useEffect, useRef } from "react";

export default function CanvasLoader({ show }: { show: boolean }) {
  const ref = useRef<HTMLCanvasElement | null>(null);

  useEffect(() => {
    if (!show || !ref.current) return;
    const canvas = ref.current;
    const ctx = canvas.getContext("2d")!;
    let raf = 0;
    let t = 0;

    const size = () => {
      canvas.width = window.innerWidth * devicePixelRatio;
      canvas.height = window.innerHeight * devicePixelRatio;
      canvas.style.width = "100%";
      canvas.style.height = "100%";
      ctx.scale(devicePixelRatio, devicePixelRatio);
    };
    size();
    window.addEventListener("resize", size);

    const loop = () => {
      t += 0.02;
      const w = canvas.width / devicePixelRatio;
      const h = canvas.height / devicePixelRatio;
      ctx.clearRect(0, 0, w, h);

      // subtle animated background
      const cx = w / 2, cy = h / 2;
      for (let i = 0; i < 24; i++) {
        const r = 50 + i * 12 + Math.sin(t + i * 0.2) * 8;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(122,162,255,${0.015 + i * 0.005})`;
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // spinner
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(t * 1.4);
      ctx.strokeStyle = "rgba(134,239,172,0.9)";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.arc(0, 0, 40, 0, Math.PI * 1.4);
      ctx.stroke();
      ctx.restore();

      raf = requestAnimationFrame(loop);
    };
    raf = requestAnimationFrame(loop);

    return () => {
      cancelAnimationFrame(raf);
      window.removeEventListener("resize", size);
    };
  }, [show]);

  return show ? (
    <div className="loaderOverlay" style={{
      position: "fixed", inset: 0, zIndex: 9999,
      background: "rgba(7, 10, 18, 0.72)", backdropFilter: "blur(2px)"
    }}>
      <canvas ref={ref} />
    </div>
  ) : null;
}
